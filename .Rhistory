##Collect market data focuses on collecting needed
##  means and sd's for use in other functions.
filepath <- system.file(package="qmj")
data(companies, package="qmj")
data(balancesheets, package="qmj")
data(cashflows, package="qmj")
data(incomestatements, package="qmj")
#companies <- read.csv(paste(filepath, "/companies.csv", sep=''))
numCompanies <- length(companies$tickers)
BS <- balancesheets
CF <- cashflows
IS <- incomestatements
#What to do with missing data?
# If we're missing a lot of data, then simply assigning 0's skews
# the mean and SD. However, short term solution to getting a result.
BS[is.na(BS)] <- 0
CF[is.na(CF)] <- 0
IS[is.na(IS)] <- 0
profitability <- qmj::collectmarketprofitability(companies, BS, CF, IS)
print("TEST")
growth <- qmj::collectmarketgrowth(companies, BS, CF, IS)
print("TEST")
safety <- rep(NaN, numCompanies)
print("TEST")
#safety <- qmj::collectmarketsafety(companies, BS, CF, IS)
payouts <- qmj::collectmarketpayout(companies, BS, CF, IS)
print("TEST")
names <- companies$names
tickers <- companies$tickers
data.frame(names, tickers, profitability, growth, safety, payouts)
}
test <- collectmarketdata()
bs <- balancesheets
bs[[1]]
t1 <- BS[[1]]
t1 <- bs[[1]]
t1[is.na(t1)] <- 0
t1
devtools::install_github("rynkwn/qmj")
library(qmj)
test <- collectmarketdata()
#' collectmarketdata
#'
#' Reads data from companies.csv and calculates market growth, payouts, safety, and profitability
#' for later processing.
#' @export
collectmarketdata <- function(){
##Collect market data focuses on collecting needed
##  means and sd's for use in other functions.
filepath <- system.file(package="qmj")
data(companies, package="qmj")
data(balancesheets, package="qmj")
data(cashflows, package="qmj")
data(incomestatements, package="qmj")
#companies <- read.csv(paste(filepath, "/companies.csv", sep=''))
numCompanies <- length(companies$tickers)
BS <- balancesheets
CF <- cashflows
IS <- incomestatements
#What to do with missing data?
# If we're missing a lot of data, then simply assigning 0's skews
# the mean and SD. However, short term solution to getting a result.
BS[is.na(BS)] <- 0
CF[is.na(CF)] <- 0
IS[is.na(IS)] <- 0
profitability <- qmj::collectmarketprofitability(companies, BS, CF, IS)
print("TEST")
growth <- qmj::collectmarketgrowth(companies, BS, CF, IS)
print("TEST")
safety <- rep(NaN, numCompanies)
print("TEST")
#safety <- qmj::collectmarketsafety(companies, BS, CF, IS)
payouts <- qmj::collectmarketpayout(companies, BS, CF, IS)
print("TEST")
names <- companies$names
tickers <- companies$tickers
data.frame(names, tickers, profitability, growth, safety, payouts)
}
test <- collectmarketdata()
#' collectmarketgrowth
#'
#' Given a list of companies (names and tickers), a balance sheet, a cash flow statement,
#' and an income statement, calculates GPOA, ROE, ROA, CFOA, GMAR, ACC
#' and determines the z-score of overall growth based on the paper
#' Quality Minus Junk (Asness et al.) in Appendix page A2.
#' @param x A dataframe of company names and tickers.
#' @param BS A dataframe containing balance sheet information for every company.
#' @param CF A dataframe containing cash flow information for every company.
#' @param IS A dataframe containing income statement information for every company.
#' @export
collectmarketgrowth <- function(x, BS, CF, IS){
numCompanies <- length(x$tickers)
growth <- rep(0, numCompanies)
GPOA <- rep(0, numCompanies)
ROE <- rep(0, numCompanies)
ROA <- rep(0, numCompanies)
CFOA <- rep(0, numCompanies)
GMAR <- rep(0, numCompanies)
ACC <- rep(0, numCompanies)
for(i in 1:numCompanies){
print(i)
cBS <- BS[[i]]
cBS[is.na(cBS)] <- 0
cBS <- data.frame(cBS)
cBSm3y <- cBS[,4]
cBS <- cBS[,1]
cCF <- CF[[i]]
cCF[is.na(cCF)] <- 0
cCF <- data.frame(cCF)
cCFm3y <- cCF[,4]
cCF <- cCF[,1]
cIS <- IS[[i]]
cIS[is.na(cIS)] <- 0
cIS <- data.frame(cIS)
cISm3y <- cIS[,4]
cIS <- cIS[,1]
###GROWTH
#GPOA
#(5 year change in gross profits)/Total assets
#GP - IS 6
#Total assets - BS 18
GPOA[i] <- (cIS[6] - cISm3y[6])/(cBSm3y[18])
#(5 year change in Net income)/book equity
#Net income - CF 2
# Book equity (Total equity) - BS 40
ROE[i] <- (cCF[2] - cCFm3y[2])/(cBSm3y[40])
#(5 year change in net income)/total assets
# Net income - CF 2
# Total assets - BS 18
ROA[i] <- (cCF[2] - cCFm3y[2])/(cBSm3y[18])
#(5 year change in cash flow over assets)
#Change in cash flow = net income + depreciation - change in working capital - capital expenditure
# IB (Net income) - CF 2
# Depreciation - CF 3
# Change in working capital - CF 7
# Capital expenditure - CF 9
#Total assets - BS 18
changeCF1 <- (cCF[2] + cCF[3] - cCF[7] - cCF[9])
changeCF2 <- (cCFm3y[2] + cCFm3y[3] - cCFm3y[7] - cCFm3y[9])
CFOA[i] <- (changeCF1 - changeCF2)/(cBSm3y[18])
#(5 year change in gross profit)/(total sales)
# GP - IS 6
# Total sales (total revenues) - IS 4
GMAR[i] <- (cIS[6] - cISm3y[6])/(cISm3y[4])
#(5 year change in (low) accruals)/total assets
# Low accruals = DP - (change in WC)
# DP - CF 3
#Change in working capital - CF 7
#Total assets - BS 18
accrual1 <- cCF[3] - cCF[7]
accrual2 <- cCFm3y[3] - cCFm3y[7]
ACC[i] <- (accrual1 - accrual2)/(cBSm3y[18])
}
#Scale converts the individual scores for these values into z-scores.
GPOA <- scale(GPOA)
ROE <- scale(ROE)
ROA <- scale(ROA)
CFOA <- scale(CFOA)
GMAR <- scale(GMAR)
ACC <- scale(ACC)
GPOA[is.nan(GPOA)] <- 0
ROE[is.nan(ROE)] <- 0
ROA[is.nan(ROA)] <- 0
CFOA[is.nan(CFOA)] <- 0
GMAR[is.nan(GMAR)] <- 0
ACC[is.nan(ACC)] <- 0
for(i in 1:numCompanies){
growth[i] <- GPOA[i] + ROE[i] + ROA[i] + CFOA[i] + GMAR[i] + ACC[i]
}
scale(growth)
}
test <- collectmarketdata()
#' collectmarketgrowth
#'
#' Given a list of companies (names and tickers), a balance sheet, a cash flow statement,
#' and an income statement, calculates GPOA, ROE, ROA, CFOA, GMAR, ACC
#' and determines the z-score of overall growth based on the paper
#' Quality Minus Junk (Asness et al.) in Appendix page A2.
#' @param x A dataframe of company names and tickers.
#' @param BS A dataframe containing balance sheet information for every company.
#' @param CF A dataframe containing cash flow information for every company.
#' @param IS A dataframe containing income statement information for every company.
#' @export
collectmarketgrowth <- function(x, BS, CF, IS){
numCompanies <- length(x$tickers)
growth <- rep(0, numCompanies)
GPOA <- rep(0, numCompanies)
ROE <- rep(0, numCompanies)
ROA <- rep(0, numCompanies)
CFOA <- rep(0, numCompanies)
GMAR <- rep(0, numCompanies)
ACC <- rep(0, numCompanies)
print("HELLO")
for(i in 1:numCompanies){
print(i)
cBS <- BS[[i]]
cBS[is.na(cBS)] <- 0
cBS <- data.frame(cBS)
cBSm3y <- cBS[,4]
cBS <- cBS[,1]
cCF <- CF[[i]]
cCF[is.na(cCF)] <- 0
cCF <- data.frame(cCF)
cCFm3y <- cCF[,4]
cCF <- cCF[,1]
cIS <- IS[[i]]
cIS[is.na(cIS)] <- 0
cIS <- data.frame(cIS)
cISm3y <- cIS[,4]
cIS <- cIS[,1]
###GROWTH
#GPOA
#(5 year change in gross profits)/Total assets
#GP - IS 6
#Total assets - BS 18
GPOA[i] <- (cIS[6] - cISm3y[6])/(cBSm3y[18])
#(5 year change in Net income)/book equity
#Net income - CF 2
# Book equity (Total equity) - BS 40
ROE[i] <- (cCF[2] - cCFm3y[2])/(cBSm3y[40])
#(5 year change in net income)/total assets
# Net income - CF 2
# Total assets - BS 18
ROA[i] <- (cCF[2] - cCFm3y[2])/(cBSm3y[18])
#(5 year change in cash flow over assets)
#Change in cash flow = net income + depreciation - change in working capital - capital expenditure
# IB (Net income) - CF 2
# Depreciation - CF 3
# Change in working capital - CF 7
# Capital expenditure - CF 9
#Total assets - BS 18
changeCF1 <- (cCF[2] + cCF[3] - cCF[7] - cCF[9])
changeCF2 <- (cCFm3y[2] + cCFm3y[3] - cCFm3y[7] - cCFm3y[9])
CFOA[i] <- (changeCF1 - changeCF2)/(cBSm3y[18])
#(5 year change in gross profit)/(total sales)
# GP - IS 6
# Total sales (total revenues) - IS 4
GMAR[i] <- (cIS[6] - cISm3y[6])/(cISm3y[4])
#(5 year change in (low) accruals)/total assets
# Low accruals = DP - (change in WC)
# DP - CF 3
#Change in working capital - CF 7
#Total assets - BS 18
accrual1 <- cCF[3] - cCF[7]
accrual2 <- cCFm3y[3] - cCFm3y[7]
ACC[i] <- (accrual1 - accrual2)/(cBSm3y[18])
}
#Scale converts the individual scores for these values into z-scores.
GPOA <- scale(GPOA)
ROE <- scale(ROE)
ROA <- scale(ROA)
CFOA <- scale(CFOA)
GMAR <- scale(GMAR)
ACC <- scale(ACC)
GPOA[is.nan(GPOA)] <- 0
ROE[is.nan(ROE)] <- 0
ROA[is.nan(ROA)] <- 0
CFOA[is.nan(CFOA)] <- 0
GMAR[is.nan(GMAR)] <- 0
ACC[is.nan(ACC)] <- 0
for(i in 1:numCompanies){
growth[i] <- GPOA[i] + ROE[i] + ROA[i] + CFOA[i] + GMAR[i] + ACC[i]
}
scale(growth)
}
#' collectmarketdata
#'
#' Reads data from companies.csv and calculates market growth, payouts, safety, and profitability
#' for later processing.
#' @export
collectmarketdata <- function(){
##Collect market data focuses on collecting needed
##  means and sd's for use in other functions.
filepath <- system.file(package="qmj")
data(companies, package="qmj")
data(balancesheets, package="qmj")
data(cashflows, package="qmj")
data(incomestatements, package="qmj")
#companies <- read.csv(paste(filepath, "/companies.csv", sep=''))
numCompanies <- length(companies$tickers)
BS <- balancesheets
CF <- cashflows
IS <- incomestatements
#What to do with missing data?
# If we're missing a lot of data, then simply assigning 0's skews
# the mean and SD. However, short term solution to getting a result.
BS[is.na(BS)] <- 0
CF[is.na(CF)] <- 0
IS[is.na(IS)] <- 0
profitability <- qmj::collectmarketprofitability(companies, BS, CF, IS)
print("TEST")
growth <- collectmarketgrowth(companies, BS, CF, IS)
print("TEST")
safety <- rep(NaN, numCompanies)
print("TEST")
#safety <- qmj::collectmarketsafety(companies, BS, CF, IS)
payouts <- qmj::collectmarketpayout(companies, BS, CF, IS)
print("TEST")
names <- companies$names
tickers <- companies$tickers
data.frame(names, tickers, profitability, growth, safety, payouts)
}
test <- collectmarketdata()
bs <- balancesheets
bs[[16]]
GPOA[i] <- 0
GPOA[i] <- 0})
#' collectmarketgrowth
#'
#' Given a list of companies (names and tickers), a balance sheet, a cash flow statement,
#' and an income statement, calculates GPOA, ROE, ROA, CFOA, GMAR, ACC
#' and determines the z-score of overall growth based on the paper
#' Quality Minus Junk (Asness et al.) in Appendix page A2.
#' @param x A dataframe of company names and tickers.
#' @param BS A dataframe containing balance sheet information for every company.
#' @param CF A dataframe containing cash flow information for every company.
#' @param IS A dataframe containing income statement information for every company.
#' @export
collectmarketgrowth <- function(x, BS, CF, IS){
numCompanies <- length(x$tickers)
growth <- rep(0, numCompanies)
GPOA <- rep(0, numCompanies)
ROE <- rep(0, numCompanies)
ROA <- rep(0, numCompanies)
CFOA <- rep(0, numCompanies)
GMAR <- rep(0, numCompanies)
ACC <- rep(0, numCompanies)
for(i in 1:numCompanies){
readattempt = tryCatch({
cBS <- BS[[i]]
cBS[is.na(cBS)] <- 0
cBS <- data.frame(cBS)
cBSm3y <- cBS[,4]
cBS <- cBS[,1]
cCF <- CF[[i]]
cCF[is.na(cCF)] <- 0
cCF <- data.frame(cCF)
cCFm3y <- cCF[,4]
cCF <- cCF[,1]
cIS <- IS[[i]]
cIS[is.na(cIS)] <- 0
cIS <- data.frame(cIS)
cISm3y <- cIS[,4]
cIS <- cIS[,1]
###GROWTH
#GPOA
#(5 year change in gross profits)/Total assets
#GP - IS 6
#Total assets - BS 18
GPOA[i] <- (cIS[6] - cISm3y[6])/(cBSm3y[18])
#(5 year change in Net income)/book equity
#Net income - CF 2
# Book equity (Total equity) - BS 40
ROE[i] <- (cCF[2] - cCFm3y[2])/(cBSm3y[40])
#(5 year change in net income)/total assets
# Net income - CF 2
# Total assets - BS 18
ROA[i] <- (cCF[2] - cCFm3y[2])/(cBSm3y[18])
#(5 year change in cash flow over assets)
#Change in cash flow = net income + depreciation - change in working capital - capital expenditure
# IB (Net income) - CF 2
# Depreciation - CF 3
# Change in working capital - CF 7
# Capital expenditure - CF 9
#Total assets - BS 18
changeCF1 <- (cCF[2] + cCF[3] - cCF[7] - cCF[9])
changeCF2 <- (cCFm3y[2] + cCFm3y[3] - cCFm3y[7] - cCFm3y[9])
CFOA[i] <- (changeCF1 - changeCF2)/(cBSm3y[18])
#(5 year change in gross profit)/(total sales)
# GP - IS 6
# Total sales (total revenues) - IS 4
GMAR[i] <- (cIS[6] - cISm3y[6])/(cISm3y[4])
#(5 year change in (low) accruals)/total assets
# Low accruals = DP - (change in WC)
# DP - CF 3
#Change in working capital - CF 7
#Total assets - BS 18
accrual1 <- cCF[3] - cCF[7]
accrual2 <- cCFm3y[3] - cCFm3y[7]
ACC[i] <- (accrual1 - accrual2)/(cBSm3y[18])
}, error = function(e){
GPOA[i] <- 0
ROE[i] <- 0
ROA[i] <- 0
CFOA[i] <- 0
GMAR[i] <- 0
ACC[i] <- 0
})
}
#Scale converts the individual scores for these values into z-scores.
GPOA <- scale(GPOA)
ROE <- scale(ROE)
ROA <- scale(ROA)
CFOA <- scale(CFOA)
GMAR <- scale(GMAR)
ACC <- scale(ACC)
GPOA[is.nan(GPOA)] <- 0
ROE[is.nan(ROE)] <- 0
ROA[is.nan(ROA)] <- 0
CFOA[is.nan(CFOA)] <- 0
GMAR[is.nan(GMAR)] <- 0
ACC[is.nan(ACC)] <- 0
for(i in 1:numCompanies){
growth[i] <- GPOA[i] + ROE[i] + ROA[i] + CFOA[i] + GMAR[i] + ACC[i]
}
scale(growth)
}
#' collectmarketpayout
#'
#' Given a list of companies (names and tickers), a balance sheet, a cash flow statement,
#' and an income statement, calculates EISS, DISS, NPOP
#' and determines the z-score of overall payout based on the paper
#' Quality Minus Junk (Asness et al.) in Appendix page A3-4.
#' @param x A dataframe of company names and tickers.
#' @param BS A dataframe containing balance sheet information for every company.
#' @param CF A dataframe containing cash flow information for every company.
#' @param IS A dataframe containing income statement information for every company.
#' @export
collectmarketpayout <- function(x, BS, CF, IS){
# CollectMarketPayout collects data on overall payouts
## In the market for individual companies for later processing.
## x is the list of companies to be processed. BS, CF, IS are financial statements.
numCompanies <- length(x$tickers)
payouts <- rep(0, numCompanies)
EISS <- rep(0, numCompanies)
DISS <- rep(0, numCompanies)
NPOP <- rep(0, numCompanies)
for(i in 1:numCompanies){
readattempt = tryCatch({
cBS <- BS[[i]]
cBS[is.na(cBS)] <- 0
cBS <- data.frame(cBS)
cBSm1y <- cBS[,2]
cBSm2y <- cBS[,3]
cBSm3y <- cBS[,4]
cBS <- cBS[,1]
cCF <- CF[[i]]
cCF[is.na(cCF)] <- 0
cCF <- data.frame(cCF)
cCFm1y <- cCF[,2]
cCFm2y <- cCF[,3]
cCFm3y <- cCF[,4]
cCF <- cCF[,1]
cIS <- IS[[i]]
cIS[is.na(cCF)] <- 0
cIS <- data.frame(cIS)
cISm1y <- cIS[,2]
cISm2y <- cIS[,3]
cISm3y <- cIS[,4]
cIS <- cIS[,1]
#EISS
# Issuance (retirement) of stock, net - CF 14
##Total number of Shares - BS 43
EISS[i] <- -log(cBS[43]/cBSm1y[43])
#DISS
# Issuance (retirement) of debt, net - CF 15
#Total debt - BS 28
DISS[i] <- -log(cBS[28]/cBSm1y[28])
#NPOP
# (Net income - changes in book equity) / (total profits over the past 5 years)
# Net income - CF 2
# Total equity - BS 40
# Gross profits - IS 6
totalNetPayouts <- (cCF[2] - cBS[40]) + (cCFm1y[2] - cBSm1y[40]) + (cCFm2y[2] - cBSm2y[40]) + (cCFm3y[2] - cBSm3y[40])
totalProfits <- cIS[6] + cISm1y[6] + cISm2y[6] + cISm3y[6]
NPOP[i] <- totalNetPayouts/totalProfits
}, error = function(e){
EISS[i] <- 0
DISS[i] <- 0
NPOP[i] <- 0
})
}
#Scale converts the individual scores for these values into z-scores.
EISS <- scale(EISS)
DISS <- scale(DISS)
NPOP <- scale(NPOP)
EISS[is.na(EISS)] <- 0
DISS[is.na(DISS)] <- 0
NPOP[is.na(NPOP)] <- 0
for(i in 1:numCompanies){
payouts[i] <- EISS[i] + DISS[i] + NPOP[i]
}
scale(payouts)
}
?qmj
library(qmj)
?qmj
#' Quality Minus Junk
#'
#' Calculates and manipulates data on the quality of companies.
#'
#' *This package is currently still in early development.* \cr
#'   RECOMMENDATION FOR EARLY USE: \cr
#'   \itemize{
#'   \item All functions and datasets are documented, and are freely available for use.
#'   \item getcompanies() is an alternative way of accessing the companies.RData data.
#'   \item collectmarketdata() provides an early look into *very rough* initial calculations
#'   for quality in the sample companies.
#'   \item *Warning*: Do not call getcashflows, getincomestatements, or getbalancesheets.
#'   While these functions correctly work, the functions do require several minutes to
#'   fully finish downloading the relevant financial documents from the web, returning
#'   a large matrix containing the desired documents.
#'   }
#'
#' @docType package
#' @name qmj
NULL
roxygenize(".")
library(roxygen2)
roxygenize(".")
setwd("econ20/R Paper/Discrete")
roxygenize(".")
