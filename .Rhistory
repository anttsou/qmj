collectmarketsafety <- function(x, BS, CF, IS){
# CollectMarketProfitability collects data on overall safety
## In the market for individual companies for later processing.
## x is the list of companies to be processed. BS, CF, IS are financial statements.
numCompanies <- length(x$tickers)
safety <- rep(0, numCompanies)
BAB <- rep(0, numCompanies)
IVOL <- rep(0, numCompanies)
LEV <- rep(0, numCompanies)
O <- rep(0, numCompanies)
Z <- rep(0, numCompanies)
EVOL <- rep(0, numCompanies)
benchmarkReturns <- read.csv("data/GSPC.csv")[,2]
for(i in 1:numCompanies){
cBS <- BS[,(4*i)-2]
cCF <- CF[,(4*i)-2]
cIS <- IS[,(4*i)-2]
returnsFile <- paste(x$tickers[i], ".csv", sep='')
companyFile <- read.csv(returnsFile)
companyFile <- tryCatch(
read.csv(returnsFile)
error=function(e) e
)
if(!inherits(companyFile, "error")){
#BAB
BAB[i] <- PerformanceAnalytics::CAPM.beta(companyFile[,2], benchmarkReturns)
}
}
#Scale converts the individual scores for these values into z-scores.
BAB <- scale(BAB)
#GPOA[is.nan(GPOA)] <- 0
for(i in 1:numCompanies){
safety[i] <- BAB[i]
}
scale(safety)
}
collectmarketsafety <- function(x, BS, CF, IS){
# CollectMarketProfitability collects data on overall safety
## In the market for individual companies for later processing.
## x is the list of companies to be processed. BS, CF, IS are financial statements.
numCompanies <- length(x$tickers)
safety <- rep(0, numCompanies)
BAB <- rep(0, numCompanies)
IVOL <- rep(0, numCompanies)
LEV <- rep(0, numCompanies)
O <- rep(0, numCompanies)
Z <- rep(0, numCompanies)
EVOL <- rep(0, numCompanies)
benchmarkReturns <- read.csv("data/GSPC.csv")[,2]
for(i in 1:numCompanies){
cBS <- BS[,(4*i)-2]
cCF <- CF[,(4*i)-2]
cIS <- IS[,(4*i)-2]
returnsFile <- paste(x$tickers[i], ".csv", sep='')
companyFile <- read.csv(returnsFile)
companyFile <- tryCatch(
read.csv(returnsFile)
error=function(e) e
)
if(!inherits(companyFile, "error")){
#BAB
BAB[i] <- PerformanceAnalytics::CAPM.beta(companyFile[,2], benchmarkReturns)
}
}
#Scale converts the individual scores for these values into z-scores.
BAB <- scale(BAB)
#GPOA[is.nan(GPOA)] <- 0
for(i in 1:numCompanies){
safety[i] <- BAB[i]
}
scale(safety)
}
collectmarketsafety <- function(x, BS, CF, IS){
# CollectMarketProfitability collects data on overall safety
## In the market for individual companies for later processing.
## x is the list of companies to be processed. BS, CF, IS are financial statements.
numCompanies <- length(x$tickers)
safety <- rep(0, numCompanies)
BAB <- rep(0, numCompanies)
IVOL <- rep(0, numCompanies)
LEV <- rep(0, numCompanies)
O <- rep(0, numCompanies)
Z <- rep(0, numCompanies)
EVOL <- rep(0, numCompanies)
benchmarkReturns <- read.csv("data/GSPC.csv")[,2]
for(i in 1:numCompanies){
cBS <- BS[,(4*i)-2]
cCF <- CF[,(4*i)-2]
cIS <- IS[,(4*i)-2]
returnsFile <- paste(x$tickers[i], ".csv", sep='')
companyFile <- tryCatch(
read.csv(returnsFile)
error=function(e) e
)
if(!inherits(companyFile, "error")){
#BAB
BAB[i] <- PerformanceAnalytics::CAPM.beta(companyFile[,2], benchmarkReturns)
}
}
#Scale converts the individual scores for these values into z-scores.
BAB <- scale(BAB)
#GPOA[is.nan(GPOA)] <- 0
for(i in 1:numCompanies){
safety[i] <- BAB[i]
}
scale(safety)
}
collectmarketsafety <- function(x, BS, CF, IS){
# CollectMarketProfitability collects data on overall safety
## In the market for individual companies for later processing.
## x is the list of companies to be processed. BS, CF, IS are financial statements.
numCompanies <- length(x$tickers)
safety <- rep(0, numCompanies)
BAB <- rep(0, numCompanies)
IVOL <- rep(0, numCompanies)
LEV <- rep(0, numCompanies)
O <- rep(0, numCompanies)
Z <- rep(0, numCompanies)
EVOL <- rep(0, numCompanies)
benchmarkReturns <- read.csv("data/GSPC.csv")[,2]
for(i in 1:numCompanies){
cBS <- BS[,(4*i)-2]
cCF <- CF[,(4*i)-2]
cIS <- IS[,(4*i)-2]
returnsFile <- paste(x$tickers[i], ".csv", sep='')
companyFile <- tryCatch(
read.csv(returnsFile),
error=function(e) e
)
if(!inherits(companyFile, "error")){
#BAB
BAB[i] <- PerformanceAnalytics::CAPM.beta(companyFile[,2], benchmarkReturns)
}
}
#Scale converts the individual scores for these values into z-scores.
BAB <- scale(BAB)
#GPOA[is.nan(GPOA)] <- 0
for(i in 1:numCompanies){
safety[i] <- BAB[i]
}
scale(safety)
}
test <- collectmarketdata()
View(test)
collectmarketsafety <- function(x, BS, CF, IS){
# CollectMarketProfitability collects data on overall safety
## In the market for individual companies for later processing.
## x is the list of companies to be processed. BS, CF, IS are financial statements.
numCompanies <- length(x$tickers)
safety <- rep(0, numCompanies)
BAB <- rep(0, numCompanies)
IVOL <- rep(0, numCompanies)
LEV <- rep(0, numCompanies)
O <- rep(0, numCompanies)
Z <- rep(0, numCompanies)
EVOL <- rep(0, numCompanies)
benchmarkReturns <- read.csv("data/GSPC.csv")[,2]
for(i in 1:numCompanies){
cBS <- BS[,(4*i)-2]
cCF <- CF[,(4*i)-2]
cIS <- IS[,(4*i)-2]
returnsFile <- paste(x$tickers[i], ".csv", sep='')
companyFile <- tryCatch(
read.csv(returnsFile),
error=function(e) e
)
if(!inherits(companyFile, "error")){
#BAB
BAB[i] <- PerformanceAnalytics::CAPM.beta(companyFile[,2], benchmarkReturns)
}
}
#Scale converts the individual scores for these values into z-scores.
BAB <- scale(BAB)
BAB[is.nan(BAB)] <- 0
for(i in 1:numCompanies){
safety[i] <- BAB[i]
}
scale(safety)
}
test <- collectmarketdata()
View(test)
collectmarketsafety <- function(x, BS, CF, IS){
# CollectMarketProfitability collects data on overall safety
## In the market for individual companies for later processing.
## x is the list of companies to be processed. BS, CF, IS are financial statements.
numCompanies <- length(x$tickers)
safety <- rep(0, numCompanies)
BAB <- rep(0, numCompanies)
IVOL <- rep(0, numCompanies)
LEV <- rep(0, numCompanies)
O <- rep(0, numCompanies)
Z <- rep(0, numCompanies)
EVOL <- rep(0, numCompanies)
benchmarkReturns <- read.csv("data/GSPC.csv")[,2]
for(i in 1:numCompanies){
cBS <- BS[,(4*i)-2]
cCF <- CF[,(4*i)-2]
cIS <- IS[,(4*i)-2]
returnsFile <- paste(x$tickers[i], ".csv", sep='')
companyFile <- tryCatch(
read.csv(returnsFile),
error=function(e) e
)
if(!inherits(companyFile, "error")){
#BAB
BAB[i] <- PerformanceAnalytics::CAPM.beta(companyFile[,2], benchmarkReturns)
}
}
#Scale converts the individual scores for these values into z-scores.
BAB <- scale(BAB)
BAB[is.nan(BAB)] <- 0
for(i in 1:numCompanies){
safety[i] <- BAB[i]
}
scale(safety)
}
test <- collectmarketdata()
View(test)
?TTR
View(test)
?quantmod
collectmarketdata <- function(){
##Collect market data focuses on collecting needed
##  means and sd's for use in other functions.
#We need:
# gross profits over assets (GPOA)
# Return on equity (ROE)
# return on assets (ROA)
# Cash flow over assets (GPOA)
# Gross margin (GMAR)
# Fraction of earnings composed of cash
#   i.e., low accruals, ACC
companies <- read.csv("data/companies.csv")
numCompanies <- length(companies$tickers)
BS <- read.csv("data/balancesheets.csv")
CF <- read.csv("data/cashflows.csv")
IS <- read.csv("data/incomestatements.csv")
#What to do with missing data?
# If we're missing a lot of data, then simply assigning 0's skews
# the mean and SD. However, short term solution to getting a result.
BS[is.na(BS)] <- 0
CF[is.na(CF)] <- 0
IS[is.na(IS)] <- 0
profitability <- collectmarketprofitability(companies, BS, CF, IS)
growth <- collectmarketgrowth(companies, BS, CF, IS)
safety <- collectmarketsafety(companies, BS, CF, IS)
payouts <- collectmarketpayout(companies, BS, CF, IS)
###SAFETY
#BAB
# - market beta
# Use PerformanceAnalytics
names <- companies$names
tickers <- companies$tickers
data.frame(names, tickers, profitability, growth, safety, payouts)
}
test <- collectmarketdata()
View(test)
collectmarketsafety <- function(x, BS, CF, IS){
# CollectMarketProfitability collects data on overall safety
## In the market for individual companies for later processing.
## x is the list of companies to be processed. BS, CF, IS are financial statements.
numCompanies <- length(x$tickers)
safety <- rep(0, numCompanies)
BAB <- rep(0, numCompanies)
IVOL <- rep(0, numCompanies)
LEV <- rep(0, numCompanies)
O <- rep(0, numCompanies)
Z <- rep(0, numCompanies)
EVOL <- rep(0, numCompanies)
benchmarkReturns <- read.csv("data/GSPC.csv")[,2]
for(i in 1:numCompanies){
cBS <- BS[,(4*i)-2]
cCF <- CF[,(4*i)-2]
cIS <- IS[,(4*i)-2]
returnsFile <- paste(x$tickers[i], ".csv", sep='')
companyFile <- tryCatch(
read.csv(returnsFile),
error=function(e) e
)
if(!inherits(companyFile, "error")){
#BAB
BAB[i] <- PerformanceAnalytics::CAPM.beta(companyFile[,2], benchmarkReturns)
}
print(BAB[i])
}
#Scale converts the individual scores for these values into z-scores.
BAB <- scale(BAB)
BAB[is.nan(BAB)] <- 0
for(i in 1:numCompanies){
safety[i] <- BAB[i]
}
scale(safety)
}
test <- collectmarketdata()
benchmarkReturns <- read.csv("data/GSPC.csv")[,2]
returnFile <- "data/FFG.csv"
companyFile <- read.csv(returnFile)
View(companyFile)
BAB <- PerformanceAnalytics::CAPM.beta(companyFile[,2], benchmarkReturns)
library(dplyr)
install.packages("dplyr")
library(dplyr)
BAB <- PerformanceAnalytics::CAPM.beta(companyFile[,2], benchmarkReturns)
companyFile <- read.csv("returnFile", sep=",", row.names=1)
companyFile <- read.csv(returnFile, sep=",", row.names=1)
View(companyFile)
BAB <- PerformanceAnalytics::CAPM.beta(companyFile[,2], benchmarkReturns)
BAB <- PerformanceAnalytics::CAPM.beta(companyFile[,1], benchmarkReturns)
benchmarkReturns <- read.csv("data/GSPC.csv")
benchmarkReturns <- read.csv("data/GSPC.csv", sep=',', row.names=1)
BAB <- PerformanceAnalytics::CAPM.beta(companyFile, benchmarkReturns)
BAB <- PerformanceAnalytics::CAPM.beta(companyFile, benchmarkReturns[1])
BAB <- PerformanceAnalytics::CAPM.beta(companyFile[1], benchmarkReturns[1])
View(benchmarkReturns)
View(companyFile)
companyFile[1]
benchmarkReturns <- na.rm(benchmarkReturns)
?rm.na
?na.rm
?is.na
benchmarkReturns[is.na()] <- 0
benchmarkReturns[is.na(benchmarkReturns)] <- 0
View(benchmarkReturns)
companyFile[is.na(companyFile)] <- 0
BAB <- PerformanceAnalytics::CAPM.beta(companyFile, benchmarkReturns)
BAB <- PerformanceAnalytics::CAPM.beta(companyFile[1], benchmarkReturns[1])
BAB <- PerformanceAnalytics::CAPM.beta(companyFile[,1], benchmarkReturns[,1])
BAB <- PerformanceAnalytics::CAPM.beta(companyFile, benchmarkReturns[,1])
BAB <- PerformanceAnalytics::CAPM.beta(companyFile[1], benchmarkReturns[,1])
BAB <- PerformanceAnalytics::CAPM.beta(companyFile[,1], benchmarkReturns[,1])
collectmarketsafety <- function(x, BS, CF, IS){
# CollectMarketProfitability collects data on overall safety
## In the market for individual companies for later processing.
## x is the list of companies to be processed. BS, CF, IS are financial statements.
numCompanies <- length(x$tickers)
safety <- rep(0, numCompanies)
BAB <- rep(0, numCompanies)
IVOL <- rep(0, numCompanies)
LEV <- rep(0, numCompanies)
O <- rep(0, numCompanies)
Z <- rep(0, numCompanies)
EVOL <- rep(0, numCompanies)
benchmarkReturns <- read.csv("data/GSPC.csv", sep=',', row.names=1)
for(i in 1:numCompanies){
cBS <- BS[,(4*i)-2]
cCF <- CF[,(4*i)-2]
cIS <- IS[,(4*i)-2]
returnsFile <- paste(x$tickers[i], ".csv", sep='')
companyFile <- tryCatch(
read.csv(returnsFile, sep=',', row.names=1),
error=function(e) e
)
if(!inherits(companyFile, "error")){
#BAB
BAB[i] <- PerformanceAnalytics::CAPM.beta(companyFile[,2], benchmarkReturns)
}
}
#Scale converts the individual scores for these values into z-scores.
BAB <- scale(BAB)
BAB[is.nan(BAB)] <- 0
for(i in 1:numCompanies){
safety[i] <- BAB[i]
}
scale(safety)
}
test <- collectmarketdata()
View(test)
collectmarketgrowth <- function(x, BS, CF, IS){
numCompanies <- length(x$tickers)
growth <- rep(0, numCompanies)
GPOA <- rep(0, numCompanies)
ROE <- rep(0, numCompanies)
ROA <- rep(0, numCompanies)
CFOA <- rep(0, numCompanies)
GMAR <- rep(0, numCompanies)
ACC <- rep(0, numCompanies)
for(i in 1:numCompanies){
cBS <- BS[,(4*i)-2]
cBSm3y <- BS[,(4*i)+1]
cCF <- CF[,(4*i)-2]
cCFm3y <- CF[,(4*i)+1]
cIS <- IS[,(4*i)-2]
cISm3y <- IS[,(4*i)+1]
###GROWTH
#GPOA
#(5 year change in gross profits)/Total assets
#GP - IS 6
#Total assets - BS 18
GPOA[i] <- (cIS[6] - cISm3y[6])/(cBSm3y[18])
#(5 year change in Net income)/book equity
#Net income - CF 2
# Book equity (Total equity) - BS 40
ROE[i] <- (cCF[2] - cCFm3y[2])/(cBSm3y[40])
#(5 year change in net income)/total assets
# Net income - CF 2
# Total assets - BS 18
ROA[i] <- (cCF[2] - cCFm3y[2])/(cBSm3y[18])
#(5 year change in cash flow over assets)
#Change in cash flow = net income + depreciation - change in working capital - capital expenditure
# IB (Net income) - CF 2
# Depreciation - CF 3
# Change in working capital - CF 7
# Capital expenditure - CF 9
#Total assets - BS 18
changeCF1 <- (cCF[2] + cCF[3] - cCF[7] - cCF[9])
changeCF2 <- (cCFm3y[2] + cCFm3y[3] - cCFm3y[7] - cCFm3y[9])
CFOA[i] <- (changeCF1 - changeCF2)/(cBSm3y[18])
#(5 year change in gross profit)/(total sales)
# GP - IS 6
# Total sales (total revenues) - IS 4
GMAR[i] <- (cIS[6] - cISm3y[6])/(cISm3y[4])
#(5 year change in (low) accruals)/total assets
# Low accruals = DP - (change in WC)
# DP - CF 3
#Change in working capital - CF 7
#Total assets - BS 18
accrual1 <- cCF[3] - cCF[7]
accrual2 <- cCFm3y[3] - cCFm3y[7]
ACC[i] <- (accrual1 - accrual2)/(cBSm3y[18])
}
#Scale converts the individual scores for these values into z-scores.
GPOA <- scale(GPOA)
ROE <- scale(ROE)
ROA <- scale(ROA)
CFOA <- scale(CFOA)
GMAR <- scale(GMAR)
ACC <- scale(ACC)
GPOA[is.nan(GPOA)] <- 0
ROE[is.nan(ROE)] <- 0
ROA[is.nan(ROA)] <- 0
CFOA[is.nan(CFOA)] <- 0
GMAR[is.nan(GMAR)] <- 0
ACC[is.nan(ACC)] <- 0
for(i in 1:numCompanies){
growth[i] <- GPOA[i] + ROE[i] + ROA[i] + CFOA[i] + GMAR[i] + ACC[i]
}
scale(growth)
}
test <- collectmarketdata()
library(roxygen2)
roxygenize(".")
roxygenize(".")
roxygenize(".")
roxygenize(".")
roxygenize(".")
roxygenize(".")
roxygenize(".")
roxygenize(".")
roxygenize(".")
indices <- c(8482,1586,6338,9087,1297,8674,6081,7800,8079,4854,3381,2469,5203,2841,7576,769,9199,2990,9122,3100)
length(indices)
roxygenize(".")
roxygenize(".")
profitability <- qmj::collectmarketprofitability(companies, BS, CF, IS)
?system.file
library(devtools)
?install_github
devtools::install_github("rynkwn/qmj")
devtools::install_github("rynkwn/qmj")
sessionInfo()
devtools::install_github("rynkwn/qmj")
devtools::install_github("rynkwn/qmj")
?qmj
?collectmarketdata
test <- system.file("data", package="qmj")
test
#' collectmarketdata
#'
#' Reads data from companies.csv and calculates market growth, payouts, safety, and profitability
#' for later processing.
#' @export
collectmarketdata <- function(){
##Collect market data focuses on collecting needed
##  means and sd's for use in other functions.
filepath <- system.file("data", package="qmj")
companies <- read.csv(paste(filepath, "/companies.csv", sep=''))
numCompanies <- length(companies$tickers)
BS <- read.csv(paste(filepath, "/balancesheets.csv", sep=''))
CF <- read.csv(paste(filepath, "/cashflows.csv", sep=''))
IS <- read.csv(paste(filepath, "/incomestatements.csv", sep=''))
#What to do with missing data?
# If we're missing a lot of data, then simply assigning 0's skews
# the mean and SD. However, short term solution to getting a result.
BS[is.na(BS)] <- 0
CF[is.na(CF)] <- 0
IS[is.na(IS)] <- 0
profitability <- qmj::collectmarketprofitability(companies, BS, CF, IS)
growth <- qmj::collectmarketgrowth(companies, BS, CF, IS)
safety <- qmj::collectmarketsafety(companies, BS, CF, IS)
payouts <- qmj::collectmarketpayout(companies, BS, CF, IS)
names <- companies$names
tickers <- companies$tickers
data.frame(names, tickers, profitability, growth, safety, payouts)
}
test <- collectmarketdata()
filepath <- system.file("data", package="qmj")
filepath
devtools::install_github("rynkwn/qmj")
?qmj
roxygenize(".")
devtools::install_github("rynkwn/qmj")
qmj::update()
??qmj
?collectmarketdata
?update
?install_github
devtools::install_github(repo="rynkwn/qmj")
qmj::update()
?qmj
??qmj
?update
library(qmj)
